#pragma config(Sensor, S2,     GYRO_SENSOR,    sensorAnalog)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// drive_forward_straight_line.c
// RobotC for Mindstorms NXT
//
// Drive forward in a straight line
// [David Butterworth, 2012]
//
// This program will loop forever.
// Both motors are driven at the same speed,
// but if one motor is rotating faster than
// the other, the opposite motor will be
// driven faster to compensate.
//
// The result is that the robot drives
// forward with a slight wiggling motion,
// but the resulting motion is much straighter
// than without using the encoders.

#define MOTOR_PORT_LEFT  motorC
#define MOTOR_PORT_RIGHT motorB
#define BIN_MOTOR motorA
void TaskDriveForward(int distance);
void TaskTurnLeft(float angle);
void TaskTurnRight(float angle);
void TaskDropOneBin();
task main()
{
TaskTurnRight(90);
TaskTurnLeft(90);
TaskTurnRight(90);
TaskTurnLeft(90);
}
void TaskDriveForward(int distance)
{
	int encoder_left = 0;
  int encoder_right = 0;
	// Start by driving both motors at same speed
	// A static integer is initialised only the first
	// time this code is executed, then keeps its
	// value until changed.
	while (nMotorEncoder[MOTOR_PORT_LEFT] < distance) {
    encoder_left  = nMotorEncoder[MOTOR_PORT_LEFT];
  	encoder_right = nMotorEncoder[MOTOR_PORT_RIGHT];
	  static int state = 0;

	  switch (state)
	  {
	  case 0:  // going straight
		  motor[MOTOR_PORT_LEFT]= 80;
		  motor[MOTOR_PORT_RIGHT]= 80;
		  displayText(4, "FWD");
		  break;

	  case 1:   // drifting to the right
		  motor[MOTOR_PORT_LEFT]= 60;
		  motor[MOTOR_PORT_RIGHT]= 90;
		  nxtDisplayString(4, "LEFT");
		  break;

	  case 2:     // drifting to the left
		  motor[MOTOR_PORT_LEFT]= 80;
		  motor[MOTOR_PORT_RIGHT]= 60;
		  nxtDisplayString(4, "RIGHT");
		  break;
	  } // end switch

	// Read Motor Encoders and chose next movement
	  if (nMotorEncoder[MOTOR_PORT_LEFT] == nMotorEncoder[MOTOR_PORT_RIGHT])  { state = 0; }  // Go straight
	  else if (nMotorEncoder[MOTOR_PORT_LEFT] > nMotorEncoder[MOTOR_PORT_RIGHT])  { state = 1; } // Turn left
	  else if (nMotorEncoder[MOTOR_PORT_LEFT] < nMotorEncoder[MOTOR_PORT_RIGHT])  { state = 2; } // Turn right
	  nxtDisplayString(1, "L rot cnt: %i", encoder_left);
		nxtDisplayString(2, "R rot cnt: %i", encoder_right);
	  wait1Msec(40);
		eraseDisplay();
	}
	nMotorEncoder[MOTOR_PORT_LEFT] = 0;
	nMotorEncoder[MOTOR_PORT_RIGHT] = 0;
	return;
}
void TaskTurnLeft(float angle) {
	float encoder_left = 0;
  float encoder_right = 0;
  float angle_speed = 0;
  float sum = 0;
  while (abs(sum) < angle) {
  	encoder_left  = nMotorEncoder[MOTOR_PORT_LEFT];
  	encoder_right = nMotorEncoder[MOTOR_PORT_RIGHT];
    motor[MOTOR_PORT_LEFT] = -(angle - sum);
  	motor[MOTOR_PORT_RIGHT] = (angle - sum);
  	nxtDisplayString(1, "L rot cnt: %i", encoder_left);
		nxtDisplayString(2, "R rot cnt: %i", encoder_right);
		nxtDisplayString(3, "Gyro Read: %i", sum);
		wait1Msec(40);
		angle_speed = SensorValue[GYRO_SENSOR] - 598;
  	sum = sum + (angle_speed) * .044;
		eraseDisplay();
  }
  nMotorEncoder[MOTOR_PORT_LEFT] = 0;
	nMotorEncoder[MOTOR_PORT_RIGHT] = 0;
	return;
}
void TaskTurnRight(float angle) {
	float encoder_left = 0;
  float encoder_right = 0;
  float sum = 0;
  float angle_speed = 0;
  while (sum < angle) {
  	encoder_left  = nMotorEncoder[MOTOR_PORT_LEFT];
  	encoder_right = nMotorEncoder[MOTOR_PORT_RIGHT];
  	motor[MOTOR_PORT_LEFT] = (angle - sum);
  	motor[MOTOR_PORT_RIGHT] = -(angle - sum);
  	nxtDisplayString(1, "L rot cnt: %i", encoder_left);
		nxtDisplayString(2, "R rot cnt: %i", encoder_right);
		nxtDisplayString(3, "Gyro Read: %i", sum);
		wait1Msec(40);
		eraseDisplay();
  }
  nMotorEncoder[MOTOR_PORT_LEFT] = 0;
	nMotorEncoder[MOTOR_PORT_RIGHT] = 0;
	return;
}
void TaskDropOneBin()
{
  int encoder_bin = 0;
  motor[MOTOR_PORT_LEFT] = 0;
	motor[MOTOR_PORT_RIGHT] = 0;
	encoder_bin = nMotorEncoder[BIN_MOTOR];
	while (encoder_bin < 610) {
		encoder_bin = nMotorEncoder[BIN_MOTOR];
		motor[BIN_MOTOR] = 30;
		nxtDisplayString(3, "B rot cnt: %i", encoder_bin);
	}
	while (encoder_bin > 0) {
		encoder_bin = nMotorEncoder[BIN_MOTOR];
		motor[BIN_MOTOR] = -30;
	}
	return;
}
